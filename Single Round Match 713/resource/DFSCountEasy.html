<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Fox Ciel has a simple undirected graph with n vertices.
The vertices are numbered 0 through n-1.
The graph is connected: you can get from any vertex to any other vertex by following some sequence of edges.<br></br>
You are given a String[] <b>G</b> containing the adjacency matrix of the graph.
More precisely, for each i and j, <b>G</b>[i][j] is 'Y' if there is an edge between vertices i and j and it is 'N' if there is no such edge.
<br></br>
<br></br>
Ciel then implemented a depth-first search:  
<br></br>
<br></br>
<pre>
p = []

dfs(current) := 
	p.append(current)
	Let adjs[] = list of vertices that are adjacent to current.
	random_shuffle(adjs)
	for v in adjs:
		if v is not in p:
			dfs(v)

Let start = random(0, n-1)   # a random number between 0 and n-1, inclusive
dfs(start)
output(p)
</pre>
<br></br>
<br></br>
Clearly, the output of this algorithm is always a permutation of the numbers from 0 to n-1.
However, as the algorithm uses randomness, there may be multiple possible outputs.
Please compute and return the number of different permutations the algorithm may return.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>DFSCountEasy</td></tr><tr><td>Method:</td><td>count</td></tr><tr><td>Parameters:</td><td>String[]</td></tr><tr><td>Returns:</td><td>long</td></tr><tr><td>Method signature:</td><td>long count(String[] G)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 1 and 13, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>G</b> will contain exactly n elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>G</b> will contain exactly n characters.</td></tr><tr><td align="center" valign="top">-</td><td>Each character in <b>G</b> will be 'N' or 'Y'.</td></tr><tr><td align="center" valign="top">-</td><td>For any valid i, <b>G</b>[i][i] = 'N'.</td></tr><tr><td align="center" valign="top">-</td><td>For any valid i and j, <b>G</b>[i][j] = <b>G</b>[j][i].</td></tr><tr><td align="center" valign="top">-</td><td>The graph described by <b>G</b> will be connected.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYY&quot;,
 &quot;YNY&quot;,
 &quot;YYN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 6</pre></td></tr><tr><td><table><tr><td colspan="2">We have a complete graph with 3 nodes. So we have all 3! = 6 possible dfs sequence.
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYNN&quot;,
 &quot;YNYN&quot;,
 &quot;NYNY&quot;,
 &quot;NNYN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 6</pre></td></tr><tr><td><table><tr><td colspan="2">This time the graph is a line: 0 - 1 - 2 - 3.
These are the possible outputs:
<ul>
<li>0,1,2,3</li>
<li>1,0,2,3</li>
<li>1,2,3,0</li>
<li>2,1,0,3</li>
<li>2,3,1,0</li>
<li>3,2,1,0</li>
</ul></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYYY&quot;,
 &quot;YNYY&quot;,
 &quot;YYNN&quot;,
 &quot;YYNN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 16</pre></td></tr><tr><td><table><tr><td colspan="2">This graph looks as follows:
<pre>
  2
 / \
0---1
 \ /
  3
</pre>
There are 16 possible permutations:
<ul>
<li>0,1,2,3</li>
<li>0,1,3,2</li>
<li>0,2,1,3</li>
<li>0,3,1,2</li>
<li>1,0,2,3</li>
<li>1,0,3,2</li>
<li>1,2,0,3</li>
<li>1,3,0,2</li>
<li>2,0,1,3</li>
<li>2,0,3,1</li>
<li>2,1,0,3</li>
<li>2,1,3,0</li>
<li>3,0,1,2</li>
<li>3,0,2,1</li>
<li>3,1,0,2</li>
<li>3,1,2,0</li>
</ul></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYYYYYYYYYYYY&quot;,
 &quot;YNYYYYYYYYYYY&quot;,
 &quot;YYNYYYYYYYYYY&quot;,
 &quot;YYYNYYYYYYYYY&quot;,
 &quot;YYYYNYYYYYYYY&quot;,
 &quot;YYYYYNYYYYYYY&quot;,
 &quot;YYYYYYNYYYYYY&quot;,
 &quot;YYYYYYYNYYYYY&quot;,
 &quot;YYYYYYYYNYYYY&quot;,
 &quot;YYYYYYYYYNYYY&quot;,
 &quot;YYYYYYYYYYNYY&quot;,
 &quot;YYYYYYYYYYYNY&quot;,
 &quot;YYYYYYYYYYYYN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 6227020800</pre></td></tr><tr><td><table><tr><td colspan="2">The answer is 13!.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;N&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>